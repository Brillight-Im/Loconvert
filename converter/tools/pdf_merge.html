<!doctype html>
<html lang="ko">
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>PDF Merge (Drag & Drop + Grid Reorder)</title>
<link rel="stylesheet" href="../styles.css">
<link rel="stylesheet" href="../shared/tool.css">
<script src="../vendor/pdf-lib/pdf-lib.min.js"></script>
<header class="site-top">
  <div class="container">
    <div class="brand">
      <a href="../index.html" style="display:flex;gap:10px;align-items:center;text-decoration:none;color:inherit;">
        <svg class="logo" viewBox="0 0 24 24" aria-hidden="true"><path d="M2 12L22 2 13 22 11 13 2 12" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>
        <span>Loconvert</span>
      </a>
    </div>
    <span class="tag">Localâ€‘only</span>
  </div>
</header>

<div class="tool-head">
  <h1>PDF í•©ì¹˜ê¸° Â· í˜ì´ì§€ ê²©ì ì •ë ¬</h1>
  <div class="toolbar">
    <input id="file" type="file" accept="application/pdf" multiple hidden>
    <label class="btn" id="pick" for="file">íŒŒì¼ ì„ íƒ</label>
    <button class="btn alt" id="clear">ëª¨ë‘ ë¹„ìš°ê¸°</button>
    <button class="btn push-right" id="download" disabled>í•©ì¹œ PDF ë‹¤ìš´ë¡œë“œ</button>
  </div>
  <div class="statusbar">
    <div class="left">
      <strong>ì´ í˜ì´ì§€:</strong> <span id="count">0</span>
      <span id="status" style="color:#666"></span>
    </div>
    <progress id="prog" max="100" value="0" style="display:none"></progress>
  </div>
</div>

<div class="zone">
  <div id="drop" class="drop">
    <strong>ì—¬ê¸°ì— PDF íŒŒì¼ì„ ë“œë˜ê·¸&ë“œë¡­</strong> í•˜ê±°ë‚˜ <em>íŒŒì¼ ì„ íƒ</em> ë²„íŠ¼ì„ ì‚¬ìš©í•˜ì„¸ìš”.<br>
    ì—¬ëŸ¬ PDFë¥¼ ë„£ìœ¼ë©´ ëª¨ë“  í˜ì´ì§€ê°€ ì•„ë˜ ê²©ìë¡œ ë‚˜ì—´ë©ë‹ˆë‹¤. ì¸ë„¤ì¼ì„ ë“œë˜ê·¸í•´ ìˆœì„œë¥¼ ë°”ê¾¸ì„¸ìš”.
    <div style="margin-top:10px;color:#777;font-size:12px">íŒ: íƒ€ì¼ì˜ Â·Â·Â· ë©”ë‰´ë¡œ <u>ì‚­ì œ/íšŒì „</u> ê°€ëŠ¥í•©ë‹ˆë‹¤.</div>
  </div>

  <div id="grid" class="grid"></div>
</div>

<!-- í•˜ë‹¨ ê³ ì • í‘¸í„°ëŠ” ì œê±° (ìƒë‹¨ íˆ´ë°”+ìƒíƒœë°”ë¡œ í†µí•©) -->

<script>
  // ===== ë¼ì´ë¸ŒëŸ¬ë¦¬ ë¡œë“œ =====
  let PDFJS = null;
  let PDFDocument = null;
  let degrees = null;
  
  async function ensureLibs() {
    if (PDFDocument && degrees) return true;
    try {
      // PDF-libì€ ì´ë¯¸ ë¡œë“œë¨
      if (window.PDFLib) {
        PDFDocument = window.PDFLib.PDFDocument;
        degrees = window.PDFLib.degrees;
        return true;
      }
      
      statusEl.textContent = 'PDF-lib ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.';
      return false;
    } catch (e) {
      console.error('ë¼ì´ë¸ŒëŸ¬ë¦¬ ë¡œë“œ ì‹¤íŒ¨', e);
      statusEl.textContent = 'ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ ë¶ˆëŸ¬ì˜¤ì§€ ëª»í–ˆìŠµë‹ˆë‹¤: ' + e.message;
      return false;
    }
  }

  // ===== ìš”ì†Œ =====
  const fileInput = document.getElementById('file');
  const pickBtn = document.getElementById('pick');
  const dropZone = document.getElementById('drop');
  const grid = document.getElementById('grid');
  const clearBtn = document.getElementById('clear');
  const dlBtn = document.getElementById('download');
  const countEl = document.getElementById('count');
  const statusEl = document.getElementById('status');
  const prog = document.getElementById('prog');

  // ===== ìƒíƒœ =====
  // pages: [{id, fileKey, pageIndex, buffer(ArrayBuffer), rotation(0/90/180/270)}]
  let pages = [];
  // ìºì‹œ: íŒŒì¼ë³„ë¡œ pdf.js ë¬¸ì„œì™€ pdf-lib ë¬¸ì„œ ë³´ê´€ (ì¤‘ë³µ íŒŒì‹± ë°©ì§€)
  const cache = new Map(); // key: fileKey â†’ { buffer, pdfjs, pdflib }
  
  // ë©€í‹°ì…€ë ‰íŠ¸ ìƒíƒœ
  const selectedTiles = new Set();
  let lastSelected = null;
  
  // íŒŒì¼ë³„ ê·¸ë¦¼ì ìƒ‰ìƒ
  const shadowColors = [
    'rgba(59, 91, 219, 0.3)',   // ë¸”ë£¨
    'rgba(16, 185, 129, 0.3)',  // ê·¸ë¦°
    'rgba(245, 158, 11, 0.3)',  // ì•°ë²„
    'rgba(239, 68, 68, 0.3)',   // ë ˆë“œ
    'rgba(139, 92, 246, 0.3)',  // í¼í”Œ
    'rgba(236, 72, 153, 0.3)',  // í•‘í¬
    'rgba(20, 184, 166, 0.3)',  // í‹¸
    'rgba(251, 113, 133, 0.3)'  // ë¡œì¦ˆ
  ];

  // ===== íŒŒì¼ ì¶”ê°€ ì²˜ë¦¬ =====
  async function addFiles(fileList) {
    // í•„ìš” ë¼ì´ë¸ŒëŸ¬ë¦¬ ì¤€ë¹„
    if (!(await ensureLibs())) return;
    const files = [...fileList].filter(isPdfFile);
    if (!files.length) return;

    // ì§„í–‰ë¥  í‘œì‹œ
    prog.style.display = 'block';
    prog.value = 0;
    statusEl.textContent = 'PDF íŒŒì¼ ë¶„ì„ ì¤‘â€¦';

    // íŒŒì¼ ë‹¨ìœ„ë¡œ ì²˜ë¦¬
    let processed = 0;
    for (const f of files) {
      const key = await fileKeyFromFile(f);
      if (!cache.has(key)) {
        const buf = await f.arrayBuffer();
        cache.set(key, { buffer: buf, pdflib: null, name: f.name });
      }
      
      const entry = cache.get(key);
      
      // PDF-libìœ¼ë¡œ í˜ì´ì§€ ìˆ˜ í™•ì¸
      try {
        if (!entry.pdflib) entry.pdflib = await PDFDocument.load(entry.buffer);
        const doc = entry.pdflib;
        const pageCount = doc.getPageCount();
        
        for (let i = 0; i < pageCount; i++) {
          // ê°„ë‹¨í•œ ì¸ë„¤ì¼ (PDF ì•„ì´ì½˜ + ì •ë³´)
          const placeholder = createPdfPlaceholder();
          
          // ìƒíƒœ ì¶”ê°€
          const id = crypto.randomUUID();
          pages.push({ id, fileKey: key, pageIndex: i, buffer: entry.buffer, rotation: 0, name: entry.name });

          // íƒ€ì¼ DOM ì¶”ê°€
          addTile({ id, canvas: placeholder, fileName: entry.name, pageNo: i + 1 });
          updateCount();
        }
      } catch (e) {
        console.error('PDF ë¶„ì„ ì‹¤íŒ¨:', e);
        // ì‹¤íŒ¨í•´ë„ 1í˜ì´ì§€ë¡œ ê°€ì •
        const placeholder = createPdfPlaceholder();
        const id = crypto.randomUUID();
        pages.push({ id, fileKey: key, pageIndex: 0, buffer: entry.buffer, rotation: 0, name: entry.name });
        addTile({ id, canvas: placeholder, fileName: entry.name, pageNo: 1 });
        updateCount();
      }
      
      processed++;
      prog.value = Math.round(processed / files.length * 100);
    }
    statusEl.textContent = '';
    prog.style.display = 'none';
    enableDownloadIfAny();
  }

  // PDF í”Œë ˆì´ìŠ¤í™€ë” ìº”ë²„ìŠ¤ ìƒì„±
  function createPdfPlaceholder() {
    const canvas = document.createElement('canvas');
    canvas.width = 120;
    canvas.height = 160;
    const ctx = canvas.getContext('2d');
    
    // ë°°ê²½
    ctx.fillStyle = '#f8f9fa';
    ctx.fillRect(0, 0, 120, 160);
    
    // í…Œë‘ë¦¬
    ctx.strokeStyle = '#dee2e6';
    ctx.lineWidth = 2;
    ctx.strokeRect(1, 1, 118, 158);
    
    // PDF ì•„ì´ì½˜
    ctx.fillStyle = '#dc3545';
    ctx.font = 'bold 16px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText('PDF', 60, 80);
    
    // íŒŒì¼ ì•„ì´ì½˜
    ctx.strokeStyle = '#6c757d';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(30, 40);
    ctx.lineTo(75, 40);
    ctx.lineTo(90, 55);
    ctx.lineTo(90, 120);
    ctx.lineTo(30, 120);
    ctx.closePath();
    ctx.stroke();
    
    return canvas;
  }

  function fileKeyFromFile(f) {
    // ê°™ì€ íŒŒì¼ì„ ë‹¤ì‹œ ì¶”ê°€í–ˆì„ ë•Œë„ ì¤‘ë³µ ìºì‹±ë˜ë„ë¡ ì´ë¦„+í¬ê¸°+mtime ë¹„ìŠ·í•œ í‚¤ë¥¼ ìƒì„±
    return new Promise(res => {
      const reader = new FileReader();
      reader.onload = () => {
        // ê°„ë‹¨ í‚¤ (ì´ë¦„/í¬ê¸°/ì•ë¶€ë¶„ í•´ì‹œ)
        const prefix = new Uint8Array(reader.result.slice(0, 1024));
        let sum = 0; for (const b of prefix) sum = (sum + b) % 65536;
        res(`${f.name}:${f.size}:${sum}`);
      };
      reader.readAsArrayBuffer(f.slice(0, 1024));
    });
  }

  // ===== íƒ€ì¼ DOM ìƒì„± =====
  function addTile({ id, canvas, fileName, pageNo }) {
    const tile = document.createElement('div');
    tile.className = 'tile';
    tile.draggable = true;
    tile.dataset.id = id;

    // íŒŒì¼ë³„ ìƒ‰ìƒ ì§€ì • (íŒŒì¼ëª… í•´ì‹œ ê¸°ë°˜)
    const colorIndex = Array.from(fileName).reduce((acc, char) => acc + char.charCodeAt(0), 0) % shadowColors.length;
    const shadowColor = shadowColors[colorIndex];
    canvas.style.boxShadow = `0 4px 12px ${shadowColor}`;

    // ìº”ë²„ìŠ¤ ë¨¼ì €
    canvas.style.display = 'block';
    tile.appendChild(canvas);
    
    // íŒŒì¼ëª…ì„ í•˜ë‹¨ì—
    const filename = document.createElement('div');
    filename.className = 'filename';
    filename.textContent = `${fileName} Â· p.${pageNo}`;
    tile.appendChild(filename);

    // í™€ë“œì‹œ ë‚˜íƒ€ë‚  ì•¡ì…˜ ë²„íŠ¼ë“¤
    const actions = document.createElement('div');
    actions.className = 'actions';
    actions.style.display = 'none';

    const rotateBtn = document.createElement('button');
    rotateBtn.className = 'action-btn';
    rotateBtn.title = '90Â° íšŒì „';
    rotateBtn.textContent = 'â†»';
    rotateBtn.onclick = (e) => {
      e.stopPropagation();
      rotatePage(id, canvas);
    };

    const delBtn = document.createElement('button');
    delBtn.className = 'action-btn';
    delBtn.title = 'ì‚­ì œ';
    delBtn.textContent = 'ğŸ—‘ï¸';
    delBtn.onclick = (e) => {
      e.stopPropagation();
      removePage(id, tile);
    };

    actions.append(rotateBtn, delBtn);
    tile.appendChild(actions);

    // ì„ íƒ ìƒíƒœ ê´€ë¦¬
    tile.addEventListener('click', (e) => {
      if (e.ctrlKey || e.metaKey) {
        toggleSelect(tile);
      } else if (e.shiftKey && lastSelected) {
        selectRange(lastSelected, tile);
      } else {
        clearSelection();
        selectTile(tile);
      }
    });

    // í™€ë“œ ì´ë²¤íŠ¸ (ë“œë˜ê·¸ì™€ ë¶„ë¦¬)
    let holdTimer;
    let isDragging = false;
    
    tile.addEventListener('mousedown', (e) => {
      if (e.button !== 0) return; // ì¢Œí´ë¦­ë§Œ
      
      holdTimer = setTimeout(() => {
        if (!isDragging) {
          actions.style.display = 'flex';
        }
      }, 800);
    });
    
    tile.addEventListener('dragstart', () => {
      isDragging = true;
      clearTimeout(holdTimer);
      actions.style.display = 'none';
    });
    
    tile.addEventListener('dragend', () => {
      isDragging = false;
    });
    
    tile.addEventListener('mouseup', () => {
      clearTimeout(holdTimer);
    });
    
    tile.addEventListener('mouseleave', () => {
      clearTimeout(holdTimer);
      actions.style.display = 'none';
    });

    grid.appendChild(tile);
  }

  function escapeHtml(s){return s.replaceAll('&','&amp;').replaceAll('<','&lt;').replaceAll('>','&gt;')}

  function updateCount(){ countEl.textContent = String(pages.length); }

  function enableDownloadIfAny(){
    const ok = pages.length > 0;
    dlBtn.disabled = !ok;
  }

  // ===== íšŒì „/ì‚­ì œ =====
  function rotatePage(id, canvasEl) {
    const p = pages.find(x => x.id === id);
    if (!p) return;
    p.rotation = (p.rotation + 90) % 360;

    // ì¸ë„¤ì¼ë„ ì‹œê°ì ìœ¼ë¡œ íšŒì „ (CSS transform)
    canvasEl.style.transform = `rotate(${p.rotation}deg)`;
  }

  function removePage(id, tile) {
    pages = pages.filter(x => x.id !== id);
    tile.remove();
    updateCount();
    enableDownloadIfAny();
  }

  // ===== ë“œë˜ê·¸ ì •ë ¬ =====
  let dragId = null;
  grid.addEventListener('dragstart', (e) => {
    const tile = e.target.closest('.tile');
    if (!tile) return;
    dragId = tile.dataset.id;
    tile.classList.add('dragging');
    e.dataTransfer.effectAllowed = 'move';
    // íŒŒì´ì–´í­ìŠ¤ í˜¸í™˜: setData í•„ìš”
    try { e.dataTransfer.setData('text/plain', dragId); } catch {}
  });
  grid.addEventListener('dragend', (e) => {
    const tile = e.target.closest('.tile');
    if (tile) tile.classList.remove('dragging');
    grid.classList.remove('drag-end');
    grid.querySelectorAll('.tile.drop-target').forEach(t=>t.classList.remove('drop-target'));
  });
  grid.addEventListener('dragover', (e) => {
    e.preventDefault();
    const after = getDragAfterElement(grid, e.clientY, e.clientX);
    const dragging = grid.querySelector('.tile.dragging');
    if (!dragging) return;
    // ì‹œê° í”¼ë“œë°±
    grid.querySelectorAll('.tile.drop-target').forEach(t=>t.classList.remove('drop-target'));
    if (after == null) {
      grid.classList.add('drag-end');
      grid.appendChild(dragging);
    } else {
      grid.classList.remove('drag-end');
      after.classList.add('drop-target');
      grid.insertBefore(dragging, after);
    }
  });
  grid.addEventListener('drop', () => {
    // DOM ìˆœì„œë¥¼ ìƒíƒœ ë°°ì—´ì— ë°˜ì˜
    const order = [...grid.querySelectorAll('.tile')].map(t => t.dataset.id);
    pages.sort((a,b) => order.indexOf(a.id) - order.indexOf(b.id));
    grid.classList.remove('drag-end');
    grid.querySelectorAll('.tile.drop-target').forEach(t=>t.classList.remove('drop-target'));
  });

  function getDragAfterElement(container, y, x) {
    const els = [...container.querySelectorAll('.tile:not(.dragging)')];
    return els.reduce((closest, child) => {
      const rect = child.getBoundingClientRect();
      const offset = y - (rect.top + rect.height / 2);
      if (offset < 0 && offset > closest.offset) {
        return { offset, element: child };
      } else {
        return closest;
      }
    }, { offset: Number.NEGATIVE_INFINITY }).element;
  }

  // ===== ë³‘í•© & ë‹¤ìš´ë¡œë“œ =====
  async function mergeAndDownload() {
    if (!pages.length) return;
    if (!(await ensureLibs())) return;
    dlBtn.disabled = true;
    statusEl.textContent = 'PDF ë³‘í•© ì¤‘â€¦';
    prog.style.display = 'block'; prog.value = 0;

    try {
      const out = await PDFDocument.create();

      // íŒŒì¼ë³„ë¡œ pdf-lib ë¬¸ì„œë¥¼ ìºì‹±í•´ copyPages ì„±ëŠ¥ í–¥ìƒ
      for (const [key, entry] of cache.entries()) {
        if (!entry.pdflib) entry.pdflib = await PDFDocument.load(entry.buffer);
      }

      for (let i = 0; i < pages.length; i++) {
        const p = pages[i];
        const src = cache.get(p.fileKey).pdflib;
        const [copied] = await out.copyPages(src, [p.pageIndex]);
        if (p.rotation) copied.setRotation(degrees(p.rotation));
        out.addPage(copied);
        if (i % 5 === 0) {
          prog.value = Math.round((i + 1) / pages.length * 100);
        }
      }

      const bytes = await out.save();
      const blob = new Blob([bytes], { type: "application/pdf" });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = "merged.pdf";
      a.click();
      URL.revokeObjectURL(a.href);
    } catch (e) {
      alert("ë³‘í•© ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: " + e.message);
      console.error(e);
    } finally {
      prog.style.display = 'none';
      statusEl.textContent = '';
      enableDownloadIfAny();
    }
  }

  // ===== ì´ë²¤íŠ¸ =====
  // ë¼ë²¨ì„ ì´ìš©í•´ Safari ë“±ì—ì„œë„ í™•ì‹¤íˆ íŒŒì¼ ì„ íƒ ë™ì‘
  fileInput.onchange = () => addFiles(fileInput.files);

  // í˜ì´ì§€ ì–´ë””ì„œë“  ê¸°ë³¸ ë“œë¡­ ë™ì‘ ë¬´ë ¥í™” (ë¸Œë¼ìš°ì €ê°€ ì—´ì§€ ì•Šë„ë¡)
  ['dragover','drop'].forEach(ev => document.addEventListener(ev, e => e.preventDefault()));

  ;['dragenter','dragover'].forEach(ev=>{
    dropZone.addEventListener(ev, e=>{ e.preventDefault(); dropZone.classList.add('dragover'); });
  });
  ;['dragleave','drop'].forEach(ev=>{
    dropZone.addEventListener(ev, e=>{ e.preventDefault(); dropZone.classList.remove('dragover'); });
  });
  dropZone.addEventListener('drop', e => {
    const files = e.dataTransfer?.files || [];
    addFiles(files);
  });

  clearBtn.onclick = () => {
    pages = [];
    grid.innerHTML = '';
    updateCount();
    enableDownloadIfAny();
  };

  dlBtn.onclick = mergeAndDownload;

  function isPdfFile(f){
    if (!f) return false;
    if (f.type === 'application/pdf') return true;
    return /\.pdf$/i.test(f.name || '');
  }
</script>
</html>
