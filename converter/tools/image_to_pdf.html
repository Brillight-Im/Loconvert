<!doctype html>
<html lang="ko">
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Images to PDF (Drag & Drop + Grid Reorder)</title>
<link rel="stylesheet" href="../styles.css">
<link rel="stylesheet" href="../shared/tool.css">
<script src="../vendor/pdf-lib/pdf-lib.min.js"></script>
<header class="site-top">
  <div class="container">
    <div class="brand">
      <a href="../index.html" style="display:flex;gap:10px;align-items:center;text-decoration:none;color:inherit;">
        <svg class="logo" viewBox="0 0 24 24" aria-hidden="true"><path d="M2 12L22 2 13 22 11 13 2 12" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>
        <span>Loconvert</span>
      </a>
    </div>
  </div>
</header>

<div class="tool-head">
  <h1>이미지 → PDF · 순서 정렬</h1>
  <div class="toolbar">
    <input id="file" type="file" accept="image/*" multiple hidden>
    <label class="btn" id="pick" for="file">이미지 선택</label>
    <button class="btn alt" id="clear">모두 비우기</button>
    <button class="btn push-right" id="download" disabled>PDF 다운로드</button>
  </div>
  <div class="statusbar">
    <div class="left">
      <strong>총 이미지:</strong> <span id="count">0</span>
      <span id="status" style="color:#666"></span>
    </div>
    <progress id="prog" max="100" value="0" style="display:none"></progress>
  </div>
</div>

<div class="zone">
  <div id="drop" class="drop">
    <strong>여기에 이미지 파일을 드래그&드롭</strong> 하거나 <em>이미지 선택</em> 버튼을 사용하세요.<br>
    여러 이미지를 넣으면 아래 격자로 나열됩니다. 썸네일을 드래그해 순서를 바꾸세요.
    <div style="margin-top:10px;color:#777;font-size:12px">팁: 타일의 삭제 버튼으로 <u>불필요한 이미지 제거</u> 가능합니다.</div>
  </div>

  <div id="grid" class="grid"></div>
</div>

<script>
  // ===== 라이브러리 로드 =====
  let PDFDocument = null;
  async function ensureLib() {
    if (PDFDocument) return true;
    try {
      if (window.PDFLib) {
        PDFDocument = window.PDFLib.PDFDocument;
        return true;
      }
      statusEl.textContent = 'PDF-lib 라이브러리를 찾을 수 없습니다.';
      return false;
    } catch (e) {
      console.error('라이브러리 로드 실패', e);
      statusEl.textContent = '라이브러리를 불러오지 못했습니다: ' + e.message;
      return false;
    }
  }

  // ===== 요소 =====
  const fileInput = document.getElementById('file');
  const dropZone = document.getElementById('drop');
  const grid = document.getElementById('grid');
  const clearBtn = document.getElementById('clear');
  const dlBtn = document.getElementById('download');
  const countEl = document.getElementById('count');
  const statusEl = document.getElementById('status');
  const prog = document.getElementById('prog');

  // ===== 상태 =====
  // images: [{id, file, canvas}]
  let images = [];
  
  // 파일별 그림자 색상
  const shadowColors = [
    'rgba(59, 91, 219, 0.3)',   // 블루
    'rgba(16, 185, 129, 0.3)',  // 그린
    'rgba(245, 158, 11, 0.3)',  // 앰버
    'rgba(239, 68, 68, 0.3)',   // 레드
    'rgba(139, 92, 246, 0.3)',  // 퍼플
    'rgba(236, 72, 153, 0.3)',  // 핑크
    'rgba(20, 184, 166, 0.3)',  // 틸
    'rgba(251, 113, 133, 0.3)'  // 로즈
  ];

  // ===== 파일 추가 처리 =====
  async function addFiles(fileList) {
    const files = [...fileList].filter(isImageFile);
    if (!files.length) return;

    // 진행률 표시
    prog.style.display = 'block';
    prog.value = 0;
    statusEl.textContent = '이미지 로딩 중…';

    // 파일 단위로 처리
    let processed = 0;
    for (const file of files) {
      const { canvas, originalCanvas } = await createImageThumbnail(file);
      const id = crypto.randomUUID();
      images.push({ id, file, canvas: originalCanvas });

      // 타일 DOM 추가
      addTile({ id, canvas, fileName: file.name });
      updateCount();
      
      processed++;
      prog.value = Math.round(processed / files.length * 100);
    }
    statusEl.textContent = '';
    prog.style.display = 'none';
    enableDownloadIfAny();
  }

  // ===== 이미지 썸네일 생성 =====
  async function createImageThumbnail(file) {
    return new Promise((resolve) => {
      const img = new Image();
      img.onload = () => {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        
        // 썸네일 크기 계산 (최대 200x200, 비율 유지)
        const maxSize = 200;
        let { width, height } = img;
        if (width > height) {
          if (width > maxSize) {
            height = (height * maxSize) / width;
            width = maxSize;
          }
        } else {
          if (height > maxSize) {
            width = (width * maxSize) / height;
            height = maxSize;
          }
        }
        
        canvas.width = width;
        canvas.height = height;
        ctx.drawImage(img, 0, 0, width, height);
        
        // 원본 캔버스 저장
        const originalCanvas = document.createElement('canvas');
        originalCanvas.width = width;
        originalCanvas.height = height;
        const originalCtx = originalCanvas.getContext('2d');
        originalCtx.drawImage(img, 0, 0, width, height);
        
        resolve({ canvas, originalCanvas });
      };
      img.src = URL.createObjectURL(file);
    });
  }

  // ===== 타일 DOM 생성 =====
  function addTile({ id, canvas, fileName }) {
    const tile = document.createElement('div');
    tile.className = 'tile';
    tile.draggable = true;
    tile.dataset.id = id;

    // 파일별 색상 지정 (파일명 해시 기반)
    const colorIndex = Array.from(fileName).reduce((acc, char) => acc + char.charCodeAt(0), 0) % shadowColors.length;
    const shadowColor = shadowColors[colorIndex];

    // 이미지 캔버스 크기 제한 및 그림자
    canvas.style.maxWidth = '100%';
    canvas.style.maxHeight = '160px';
    canvas.style.objectFit = 'contain';
    canvas.style.display = 'block';
    canvas.style.boxShadow = `0 4px 12px ${shadowColor}`;
    
    tile.appendChild(canvas);
    
    // 파일명을 하단에
    const filename = document.createElement('div');
    filename.className = 'filename';
    filename.textContent = fileName;
    tile.appendChild(filename);

    // 우상단 액션 버튼들
    const actions = document.createElement('div');
    actions.className = 'actions';

    const rotateBtn = document.createElement('button');
    rotateBtn.textContent = '↻';
    rotateBtn.onclick = (e) => {
      e.stopPropagation();
      rotateImage(id, canvas);
    };

    const delBtn = document.createElement('button');
    delBtn.textContent = '✕';
    delBtn.onclick = (e) => {
      e.stopPropagation();
      removeImage(id, tile);
    };

    actions.append(rotateBtn, delBtn);
    tile.appendChild(actions);


    grid.appendChild(tile);
  }


  function escapeHtml(s) { return s.replaceAll('&','&amp;').replaceAll('<','&lt;').replaceAll('>','&gt;') }

  // ===== 회전 기능 =====
  function rotateImage(id, canvasEl) {
    const img = images.find(x => x.id === id);
    if (!img) return;
    
    // 회전 값 저장 (기본값 0)
    img.rotation = (img.rotation || 0) + 90;
    if (img.rotation >= 360) img.rotation = 0;
    
    // CSS transform 제거하고 직접 다시 드로잉
    canvasEl.style.transform = 'none';
    
    // 원본 이미지로 다시 그리기
    const originalCanvas = img.canvas;
    const ctx = canvasEl.getContext('2d');
    
    // 회전에 따라 캔버스 크기 조정
    if (img.rotation === 90 || img.rotation === 270) {
      canvasEl.width = originalCanvas.height;
      canvasEl.height = originalCanvas.width;
    } else {
      canvasEl.width = originalCanvas.width;
      canvasEl.height = originalCanvas.height;
    }
    
    ctx.save();
    ctx.translate(canvasEl.width / 2, canvasEl.height / 2);
    ctx.rotate((img.rotation * Math.PI) / 180);
    ctx.drawImage(originalCanvas, -originalCanvas.width / 2, -originalCanvas.height / 2);
    ctx.restore();
  }

  function updateCount() { countEl.textContent = String(images.length); }

  function enableDownloadIfAny() {
    const ok = images.length > 0;
    dlBtn.disabled = !ok;
  }

  // ===== 이미지 삭제 =====
  function removeImage(id, tile) {
    images = images.filter(x => x.id !== id);
    tile.remove();
    updateCount();
    enableDownloadIfAny();
  }

  // ===== 드래그 정렬 =====
  let dragId = null;
  grid.addEventListener('dragstart', (e) => {
    const tile = e.target.closest('.tile');
    if (!tile) return;
    dragId = tile.dataset.id;
    tile.classList.add('dragging');
    e.dataTransfer.effectAllowed = 'move';
    try { e.dataTransfer.setData('text/plain', dragId); } catch {}
  });
  grid.addEventListener('dragend', (e) => {
    const tile = e.target.closest('.tile');
    if (tile) tile.classList.remove('dragging');
    grid.classList.remove('drag-end');
    grid.querySelectorAll('.tile.drop-target').forEach(t=>t.classList.remove('drop-target'));
  });
  grid.addEventListener('dragover', (e) => {
    e.preventDefault();
    const after = getDragAfterElement(grid, e.clientY, e.clientX);
    const dragging = grid.querySelector('.tile.dragging');
    if (!dragging) return;
    // 시각 피드백
    grid.querySelectorAll('.tile.drop-target').forEach(t=>t.classList.remove('drop-target'));
    if (after == null) {
      grid.classList.add('drag-end');
      grid.appendChild(dragging);
    } else {
      grid.classList.remove('drag-end');
      after.classList.add('drop-target');
      grid.insertBefore(dragging, after);
    }
  });
  grid.addEventListener('drop', () => {
    // DOM 순서를 상태 배열에 반영
    const order = [...grid.querySelectorAll('.tile')].map(t => t.dataset.id);
    images.sort((a,b) => order.indexOf(a.id) - order.indexOf(b.id));
    grid.classList.remove('drag-end');
    grid.querySelectorAll('.tile.drop-target').forEach(t=>t.classList.remove('drop-target'));
  });

  function getDragAfterElement(container, y, x) {
    const els = [...container.querySelectorAll('.tile:not(.dragging)')];
    const containerRect = container.getBoundingClientRect();
    
    // 그리드의 열 수와 열 너비 계산
    const computedStyle = getComputedStyle(container);
    const gap = parseInt(computedStyle.gap) || 12;
    const containerWidth = containerRect.width;
    const minTileWidth = 160;
    const cols = Math.floor((containerWidth + gap) / (minTileWidth + gap));
    const colWidth = (containerWidth - (cols - 1) * gap) / cols;
    
    // 마우스 위치가 어느 열에 있는지 계산
    const relativeX = x - containerRect.left;
    const relativeY = y - containerRect.top;
    const col = Math.floor(relativeX / (colWidth + gap));
    const row = Math.floor(relativeY / (200 + gap));
    
    // 해당 위치의 인덱스 계산
    const targetIndex = row * cols + col;
    
    // 타겟 인덱스에 해당하는 요소 찾기
    return els[targetIndex] || null;
  }

  // ===== PDF 생성 & 다운로드 =====
  async function createAndDownload() {
    if (!images.length) return;
    if (!(await ensureLib())) return;
    dlBtn.disabled = true;
    statusEl.textContent = 'PDF 생성 중…';
    prog.style.display = 'block'; prog.value = 0;

    try {
      const doc = await PDFDocument.create();

      for (let i = 0; i < images.length; i++) {
        const imgData = images[i];
        const { file } = imgData;
        const buf = await file.arrayBuffer();
        const rotation = imgData.rotation || 0;
        
        let img, dims;
        if (file.type.includes('png')) {
          img = await doc.embedPng(buf);
          dims = img.scale(1);
        } else {
          img = await doc.embedJpg(buf);
          dims = img.scale(1);
        }
        
        // 회전에 따라 페이지 크기 조정
        let pageWidth = dims.width;
        let pageHeight = dims.height;
        if (rotation === 90 || rotation === 270) {
          pageWidth = dims.height;
          pageHeight = dims.width;
        }
        
        const page = doc.addPage([pageWidth, pageHeight]);
        
        // 회전 적용하여 이미지 그리기
        const centerX = pageWidth / 2;
        const centerY = pageHeight / 2;
        
        page.drawImage(img, {
          x: centerX - dims.width / 2,
          y: centerY - dims.height / 2,
          width: dims.width,
          height: dims.height,
          rotate: window.PDFLib.degrees(rotation)
        });
        
        if (i % 3 === 0) {
          prog.value = Math.round((i + 1) / images.length * 100);
        }
      }

      const bytes = await doc.save();
      const blob = new Blob([bytes], { type: "application/pdf" });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = "images.pdf";
      a.click();
      URL.revokeObjectURL(a.href);
    } catch (e) {
      alert("PDF 생성 중 오류가 발생했습니다: " + e.message);
      console.error(e);
    } finally {
      prog.style.display = 'none';
      statusEl.textContent = '';
      enableDownloadIfAny();
    }
  }

  // ===== 이벤트 =====
  fileInput.onchange = () => addFiles(fileInput.files);

  // 페이지 어디서든 기본 드롭 동작 무력화
  ['dragover','drop'].forEach(ev => document.addEventListener(ev, e => e.preventDefault()));

  ;['dragenter','dragover'].forEach(ev=>{
    dropZone.addEventListener(ev, e=>{ e.preventDefault(); dropZone.classList.add('dragover'); });
  });
  ;['dragleave','drop'].forEach(ev=>{
    dropZone.addEventListener(ev, e=>{ e.preventDefault(); dropZone.classList.remove('dragover'); });
  });
  dropZone.addEventListener('drop', e => {
    const files = e.dataTransfer?.files || [];
    addFiles(files);
  });

  clearBtn.onclick = () => {
    images = [];
    grid.innerHTML = '';
    updateCount();
    enableDownloadIfAny();
  };

  dlBtn.onclick = createAndDownload;

  function isImageFile(f) {
    if (!f) return false;
    if (f.type.startsWith('image/')) return true;
    return /\.(jpg|jpeg|png|gif|webp)$/i.test(f.name || '');
  }

</script>
</html>