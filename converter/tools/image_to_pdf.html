<!doctype html>
<html lang="ko">
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Images to PDF (Drag & Drop + Grid Reorder)</title>
<link rel="stylesheet" href="../styles.css">
<link rel="stylesheet" href="../shared/tool.css">
<script src="../vendor/pdf-lib/pdf-lib.min.js"></script>
<header class="site-top">
  <div class="container">
    <div class="brand">
      <a href="../index.html" style="display:flex;gap:10px;align-items:center;text-decoration:none;color:inherit;">
        <svg class="logo" viewBox="0 0 24 24" aria-hidden="true"><path d="M2 12L22 2 13 22 11 13 2 12" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>
        <span>Loconvert</span>
      </a>
    </div>
    <span class="tag">Localâ€‘only</span>
  </div>
</header>

<div class="tool-head">
  <h1>ì´ë¯¸ì§€ â†’ PDF Â· ìˆœì„œ ì •ë ¬</h1>
  <p class="sub">ì´ë¯¸ì§€ë¥¼ PDFë¡œ ë³€í™˜í•©ë‹ˆë‹¤. ë¸Œë¼ìš°ì € ë‚´ë¶€ì—ì„œë§Œ ì²˜ë¦¬í•©ë‹ˆë‹¤. ì„œë²„ ì—…ë¡œë“œ ì—†ìŒ.</p>
  <div class="toolbar">
    <input id="file" type="file" accept="image/*" multiple hidden>
    <label class="btn" id="pick" for="file">ì´ë¯¸ì§€ ì„ íƒ</label>
    <button class="btn alt" id="clear">ëª¨ë‘ ë¹„ìš°ê¸°</button>
    <button class="btn push-right" id="download" disabled>PDF ë‹¤ìš´ë¡œë“œ</button>
  </div>
  <div class="statusbar">
    <div class="left">
      <strong>ì´ ì´ë¯¸ì§€:</strong> <span id="count">0</span>
      <span id="status" style="color:#666"></span>
    </div>
    <progress id="prog" max="100" value="0" style="display:none"></progress>
  </div>
</div>

<div class="zone">
  <div id="drop" class="drop">
    <strong>ì—¬ê¸°ì— ì´ë¯¸ì§€ íŒŒì¼ì„ ë“œë˜ê·¸&ë“œë¡­</strong> í•˜ê±°ë‚˜ <em>ì´ë¯¸ì§€ ì„ íƒ</em> ë²„íŠ¼ì„ ì‚¬ìš©í•˜ì„¸ìš”.<br>
    ì—¬ëŸ¬ ì´ë¯¸ì§€ë¥¼ ë„£ìœ¼ë©´ ì•„ë˜ ê²©ìë¡œ ë‚˜ì—´ë©ë‹ˆë‹¤. ì¸ë„¤ì¼ì„ ë“œë˜ê·¸í•´ ìˆœì„œë¥¼ ë°”ê¾¸ì„¸ìš”.
    <div style="margin-top:10px;color:#777;font-size:12px">íŒ: íƒ€ì¼ì˜ ì‚­ì œ ë²„íŠ¼ìœ¼ë¡œ <u>ë¶ˆí•„ìš”í•œ ì´ë¯¸ì§€ ì œê±°</u> ê°€ëŠ¥í•©ë‹ˆë‹¤.</div>
  </div>

  <div id="grid" class="grid"></div>
</div>

<script>
  // ===== ë¼ì´ë¸ŒëŸ¬ë¦¬ ë¡œë“œ =====
  let PDFDocument = null;
  async function ensureLib() {
    if (PDFDocument) return true;
    try {
      if (window.PDFLib) {
        PDFDocument = window.PDFLib.PDFDocument;
        return true;
      }
      statusEl.textContent = 'PDF-lib ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.';
      return false;
    } catch (e) {
      console.error('ë¼ì´ë¸ŒëŸ¬ë¦¬ ë¡œë“œ ì‹¤íŒ¨', e);
      statusEl.textContent = 'ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ ë¶ˆëŸ¬ì˜¤ì§€ ëª»í–ˆìŠµë‹ˆë‹¤: ' + e.message;
      return false;
    }
  }

  // ===== ìš”ì†Œ =====
  const fileInput = document.getElementById('file');
  const dropZone = document.getElementById('drop');
  const grid = document.getElementById('grid');
  const clearBtn = document.getElementById('clear');
  const dlBtn = document.getElementById('download');
  const countEl = document.getElementById('count');
  const statusEl = document.getElementById('status');
  const prog = document.getElementById('prog');

  // ===== ìƒíƒœ =====
  // images: [{id, file, canvas}]
  let images = [];

  // ===== íŒŒì¼ ì¶”ê°€ ì²˜ë¦¬ =====
  async function addFiles(fileList) {
    const files = [...fileList].filter(isImageFile);
    if (!files.length) return;

    // ì§„í–‰ë¥  í‘œì‹œ
    prog.style.display = 'block';
    prog.value = 0;
    statusEl.textContent = 'ì´ë¯¸ì§€ ë¡œë”© ì¤‘â€¦';

    // íŒŒì¼ ë‹¨ìœ„ë¡œ ì²˜ë¦¬
    let processed = 0;
    for (const file of files) {
      const canvas = await createImageThumbnail(file);
      const id = crypto.randomUUID();
      images.push({ id, file, canvas });

      // íƒ€ì¼ DOM ì¶”ê°€
      addTile({ id, canvas, fileName: file.name });
      updateCount();
      
      processed++;
      prog.value = Math.round(processed / files.length * 100);
    }
    statusEl.textContent = '';
    prog.style.display = 'none';
    enableDownloadIfAny();
  }

  // ===== ì´ë¯¸ì§€ ì¸ë„¤ì¼ ìƒì„± =====
  async function createImageThumbnail(file) {
    return new Promise((resolve) => {
      const img = new Image();
      img.onload = () => {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        
        // ì¸ë„¤ì¼ í¬ê¸° ê³„ì‚° (ìµœëŒ€ 200x200, ë¹„ìœ¨ ìœ ì§€)
        const maxSize = 200;
        let { width, height } = img;
        if (width > height) {
          if (width > maxSize) {
            height = (height * maxSize) / width;
            width = maxSize;
          }
        } else {
          if (height > maxSize) {
            width = (width * maxSize) / height;
            height = maxSize;
          }
        }
        
        canvas.width = width;
        canvas.height = height;
        ctx.drawImage(img, 0, 0, width, height);
        resolve(canvas);
      };
      img.src = URL.createObjectURL(file);
    });
  }

  // ===== íƒ€ì¼ DOM ìƒì„± =====
  function addTile({ id, canvas, fileName }) {
    const tile = document.createElement('div');
    tile.className = 'tile';
    tile.draggable = true;
    tile.dataset.id = id;

    // ì´ë¯¸ì§€ ìº”ë²„ìŠ¤ í¬ê¸° ì œí•œ
    canvas.style.maxWidth = '100%';
    canvas.style.maxHeight = '160px';
    canvas.style.objectFit = 'contain';
    canvas.style.display = 'block';
    
    tile.appendChild(canvas);
    
    // íŒŒì¼ëª…ì„ í•˜ë‹¨ì—
    const filename = document.createElement('div');
    filename.className = 'filename';
    filename.textContent = fileName;
    tile.appendChild(filename);

    // í™€ë“œì‹œ ë‚˜íƒ€ë‚  ì•¡ì…˜ ë²„íŠ¼ë“¤
    const actions = document.createElement('div');
    actions.className = 'actions';
    actions.style.display = 'none';

    const delBtn = document.createElement('button');
    delBtn.className = 'action-btn';
    delBtn.title = 'ì‚­ì œ';
    delBtn.textContent = 'ğŸ—‘ï¸';
    delBtn.onclick = () => removeImage(id, tile);

    actions.append(delBtn);
    tile.appendChild(actions);

    // í™€ë“œ ì´ë²¤íŠ¸ ì¶”ê°€
    let holdTimer;
    const startHold = (e) => {
      e.preventDefault();
      holdTimer = setTimeout(() => {
        actions.style.display = 'flex';
      }, 500);
    };
    
    const endHold = () => {
      clearTimeout(holdTimer);
    };
    
    const hideActions = () => {
      clearTimeout(holdTimer);
      actions.style.display = 'none';
    };

    tile.addEventListener('mousedown', startHold);
    tile.addEventListener('touchstart', startHold);
    tile.addEventListener('mouseup', endHold);
    tile.addEventListener('touchend', endHold);
    tile.addEventListener('mouseleave', hideActions);
    tile.addEventListener('touchcancel', hideActions);

    grid.appendChild(tile);
  }

  function escapeHtml(s) { return s.replaceAll('&','&amp;').replaceAll('<','&lt;').replaceAll('>','&gt;') }

  function updateCount() { countEl.textContent = String(images.length); }

  function enableDownloadIfAny() {
    const ok = images.length > 0;
    dlBtn.disabled = !ok;
  }

  // ===== ì´ë¯¸ì§€ ì‚­ì œ =====
  function removeImage(id, tile) {
    images = images.filter(x => x.id !== id);
    tile.remove();
    updateCount();
    enableDownloadIfAny();
  }

  // ===== ë“œë˜ê·¸ ì •ë ¬ =====
  let dragId = null;
  grid.addEventListener('dragstart', (e) => {
    const tile = e.target.closest('.tile');
    if (!tile) return;
    dragId = tile.dataset.id;
    tile.classList.add('dragging');
    e.dataTransfer.effectAllowed = 'move';
    try { e.dataTransfer.setData('text/plain', dragId); } catch {}
  });
  grid.addEventListener('dragend', (e) => {
    const tile = e.target.closest('.tile');
    if (tile) tile.classList.remove('dragging');
    grid.classList.remove('drag-end');
    grid.querySelectorAll('.tile.drop-target').forEach(t=>t.classList.remove('drop-target'));
  });
  grid.addEventListener('dragover', (e) => {
    e.preventDefault();
    const after = getDragAfterElement(grid, e.clientY, e.clientX);
    const dragging = grid.querySelector('.tile.dragging');
    if (!dragging) return;
    // ì‹œê° í”¼ë“œë°±
    grid.querySelectorAll('.tile.drop-target').forEach(t=>t.classList.remove('drop-target'));
    if (after == null) {
      grid.classList.add('drag-end');
      grid.appendChild(dragging);
    } else {
      grid.classList.remove('drag-end');
      after.classList.add('drop-target');
      grid.insertBefore(dragging, after);
    }
  });
  grid.addEventListener('drop', () => {
    // DOM ìˆœì„œë¥¼ ìƒíƒœ ë°°ì—´ì— ë°˜ì˜
    const order = [...grid.querySelectorAll('.tile')].map(t => t.dataset.id);
    images.sort((a,b) => order.indexOf(a.id) - order.indexOf(b.id));
    grid.classList.remove('drag-end');
    grid.querySelectorAll('.tile.drop-target').forEach(t=>t.classList.remove('drop-target'));
  });

  function getDragAfterElement(container, y, x) {
    const els = [...container.querySelectorAll('.tile:not(.dragging)')];
    return els.reduce((closest, child) => {
      const rect = child.getBoundingClientRect();
      const offset = y - (rect.top + rect.height / 2);
      if (offset < 0 && offset > closest.offset) {
        return { offset, element: child };
      } else {
        return closest;
      }
    }, { offset: Number.NEGATIVE_INFINITY }).element;
  }

  // ===== PDF ìƒì„± & ë‹¤ìš´ë¡œë“œ =====
  async function createAndDownload() {
    if (!images.length) return;
    if (!(await ensureLib())) return;
    dlBtn.disabled = true;
    statusEl.textContent = 'PDF ìƒì„± ì¤‘â€¦';
    prog.style.display = 'block'; prog.value = 0;

    try {
      const doc = await PDFDocument.create();

      for (let i = 0; i < images.length; i++) {
        const { file } = images[i];
        const buf = await file.arrayBuffer();
        
        let img, dims;
        if (file.type.includes('png')) {
          img = await doc.embedPng(buf);
          dims = img.scale(1);
        } else {
          img = await doc.embedJpg(buf);
          dims = img.scale(1);
        }
        
        const page = doc.addPage([dims.width, dims.height]);
        page.drawImage(img, { x: 0, y: 0, width: dims.width, height: dims.height });
        
        if (i % 3 === 0) {
          prog.value = Math.round((i + 1) / images.length * 100);
        }
      }

      const bytes = await doc.save();
      const blob = new Blob([bytes], { type: "application/pdf" });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = "images.pdf";
      a.click();
      URL.revokeObjectURL(a.href);
    } catch (e) {
      alert("PDF ìƒì„± ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: " + e.message);
      console.error(e);
    } finally {
      prog.style.display = 'none';
      statusEl.textContent = '';
      enableDownloadIfAny();
    }
  }

  // ===== ì´ë²¤íŠ¸ =====
  fileInput.onchange = () => addFiles(fileInput.files);

  // í˜ì´ì§€ ì–´ë””ì„œë“  ê¸°ë³¸ ë“œë¡­ ë™ì‘ ë¬´ë ¥í™”
  ['dragover','drop'].forEach(ev => document.addEventListener(ev, e => e.preventDefault()));

  ;['dragenter','dragover'].forEach(ev=>{
    dropZone.addEventListener(ev, e=>{ e.preventDefault(); dropZone.classList.add('dragover'); });
  });
  ;['dragleave','drop'].forEach(ev=>{
    dropZone.addEventListener(ev, e=>{ e.preventDefault(); dropZone.classList.remove('dragover'); });
  });
  dropZone.addEventListener('drop', e => {
    const files = e.dataTransfer?.files || [];
    addFiles(files);
  });

  clearBtn.onclick = () => {
    images = [];
    grid.innerHTML = '';
    updateCount();
    enableDownloadIfAny();
  };

  dlBtn.onclick = createAndDownload;

  function isImageFile(f) {
    if (!f) return false;
    if (f.type.startsWith('image/')) return true;
    return /\.(jpg|jpeg|png|gif|webp)$/i.test(f.name || '');
  }
</script>
</html>